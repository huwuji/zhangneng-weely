

### 1. 业务-建站工具： 从建站工具的理解--组件化开始

建站工具

![1568535639(1)](./1.jpeg)

![1568536408(1)](./2.jpeg)

如上两图所示，一个是建站页面，一个是建站页面在系统编辑状态下的展示。

我们先看建站页面，从上图可以看出这个页面有两个组件，查看dom结构，我们能清晰的看到这个页面有一个package.js+data.js+两个class为module的dom结构（这里我们就称为showDom）。

这里package.js是包含这两个组件的实现方法，这个实现方法是一个html模板+css+js相关的处理函数。

我们可以理解为这个
`package.js=[{<div>+<style>+<script>},{<div>+<style>+<script>}]`

看到这里，组件在页面上展示的所有部分都已经全部具备了，那data.js是做什么用的呢？

从名称我们可以看出这个是一个数据文件。是的，这就是一个数据文件。这个数据是根据需要从package.js中的div中抽出需要被改变的数据。这个data.js也是一个数组，包含的是这个页面的组件的数据集合。

从上我们可以看出一个组件的是：

一个组件的展示=package.js[index]+data.js[index]

所以再说建站页面的组件在系统编辑也中的展示和数据交互。

如上图1所示，编辑页面分为三部分，左边的组件模块展示区，中间的组件渲染区和右边的组件具体数据修改区。

下图是整体的数据流向图

![建站](./3.png)

 根据上面说过的，这个页面我们会从后端拉到整个建站页面的package.js和data.js。

那么左边和中间渲染的交互就很简单了，当左边切换时，只用告诉中间需要渲染的是第几个就可以了。也就是这里需要的只是一个index值。

然后就是中间渲染部分和右边的数据交互了。

这里，对于中间渲染的模块可以被编辑的区域或者说dom节点，是需要我们添加上特定标识的。

```
﻿{
    "deadLine": {
        "flagDelete": "false"
    },
    "img": {
        "imgSource": "http://ggpt.sunlands.com/toolpageProd/sellPointForCDPage/banner_bg.png",
        "action": "javascript:interactive.openGreatBear(0,'',{moduleName:'sellPointForCDPage'})",
        "info": "上市头图"
    },
    "textList": [
        {
            "class": "title-one",
            "width": 330,
            "height": 23,
            "top": 65,
            "left": 35,
            "bgColor": "transparent",
            "edit": "text",
            "text": "<div style='text-align:center'><span style='font-size:16px;color:#474748'>低学历上班族报考名校1</span></div>",
            "flagDelete": "false",
            "drag": "true"
        }
    ],
}

```

 如上代码：这是一个组件的data文件部分。

当我们点击一个组件按钮时，我们能从这个dom节点上取得一个我们之前定义好的data属性，这个属性就是一个位置标识。例如：data="textList-0";我们拿到这个值然后去拆分就能拿到点击的这个dom节点上的数据。然后把数据在右侧展示，右侧数据的编辑也是对应上关系，也就是组合在上传。所以，右侧的展示，最好的方式也是中间给右侧传递一个data="textList-0"这样的一个位置标识符+之前模块位置的定位index值，就能找到右侧需要的数据。

但是，目前实现的有点不一样。逻辑思路是一样的，只是把右侧数据的获取放在了中间部分，中间部分获取到标识时，直接处理得到整个右侧的数据块，右侧只管把拿到的数据直接用就可以。右侧改变时，都是对应好了具体的属性，更改好后直接上传整个数据块。

所以中间部分和右侧其实就是一个更细致的拆分。从左到右其实也是一步步的拆分，然后再一步步组合上传保存。

-----------------------------------------------------------------------------------------------------------------------------------



-------------------------------------------------分割线-------------------------------------

 以下存是自己的乱象，若有误导，请不要参考。

### 2. 拆-组： 到拆分--再组合（配置）理念

### 3. 提效： 拆分--组合的最终目的提效。提效的向上转化，也就是提高利益。

 从提效的概念论证：
1.计算机的核心指标一个是性能，一个是功耗。这里性能个人觉得可以理解为效能，也就是效率，性能强大，单位时间里能处理的指令也就多，效率就高，计算机发展也是一个提效的过程。
2.计算机cpu(高级缓存：为实际的性能需要，说着想说的是其实有一些就是没有这么理想化)，内存（进程分开管理），gpu

那各行各业怎么提效：
1.空间转时间。也就是同一时间，多人同时开始做事。类似于多核，多线程（其实多线程也并不一定是同时开始的）；
2.1-n。两点，一个把多个拼成一个，二是一个在多处复用。
那里，逆过来想，就是把一个整体拆分成多个，然后再组合。
然后就是怎么拆，怎么组。

再看下目前已有的一些拆分实践：
    前后端分离，也是一个拆组原则。
    >>> !!! 看拆分的维度，以及拆分的参考系
1.前端:组件化，npm包，路由，单页面的产生，redux（数据流程化，我们在redux中为每个局部分配单独的store） 纯样式渲染组件，函数式编程，一个函数干一件事，webAssembly(拆组--提效，提供开发之间的效率),桌面应用， 
前端服务体系（圆心），IDE（集合体，提效工具），
大前端，grathQL
2.后端:
3.中台思想

。。。未完待续