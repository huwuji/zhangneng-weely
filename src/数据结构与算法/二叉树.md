1. 二叉树遍历
```
//二叉树-
function traversalTree(node){
	if(!node){
		return null;
	}
	// console.log('firstnode=',node.value);//先序
	if(node.left){
		traversalTreeMid(node.left);
	}
	// console.log('midnode=',node.value);//中序
	if(node.right){
		traversalTreeMid(node.right);
	}
	// console.log('railnode=',node.value);//后序
}


 const tree={
 	value:'0',
 	left:{
 		value:'1',
 		right:{
 			value:'1-1'
 		}
 	},
 	right:{
		value:'2',
 		left:{
 			value:'2-0'
 		},
 		right:{
 			value:'2-1'
 		},
 	}
 }

 traversalTree(tree)
```

2. 表达式二叉树
```
 // 后缀表达式转表达式二叉树
const express=['a','b','c','+','*','d','-'];
const op=['+','*','-'];
//表达式节点结构{left:'',right:'',operate:''}

function createExpressTree(express){
	let stack=[];
	for(let i=0;i<=express.length-1;i++){
		// if( express[i])
		if(op.includes(express[i])){
			let node={};
			node.operate=express[i];
			node.right=stack.pop();
			node.left=stack.pop();
			stack.push(node);

		}else{
			stack.push(express[i]);
		}
	}

	return stack[0];
}

console.log(createExpressTree(express));

```

3. 二叉查找树
> 主要是删除的时候操作复杂度比较大，所有有懒惰删除，并没有直接删除节点，而是在此节点上增加标记，表明已经被删除。

>思考：react的虚拟节点树，在删除节点的实现逻辑是当某一个节点被删除后，不考虑被删除节点的子节点的移动，而是直接删除，再重新构造子节点。这样的效率更高。
